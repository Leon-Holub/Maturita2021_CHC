# 20.Pokročilé techniky objektového programování

## Agregace

* Mluvíme o agregaci pokud nějaká **třída obsahuje jiné třídy (také se jím říká komponenty)**. 
* Pomocí agregace můžeme tvořit složitější třídy pomocí jednodušších. 
* Konstruktory se v takovém případě chovají tak, že dříve, než se spustí konstruktor třídy, jejíž instanci vytváříme, nejprve se vytvoří instance tříd, které tato třída obsahuje (jejich konstruktory se tedy volají dříve). Volání destruktorů probíhá přesně opačně.

### Příklad

```
#include<iostream>
#define SIZEARRAY 3
using namespace std;

class CA{
  private:
  int m_iNumber;
  
  public:
    CA():m_iNumber(SIZEARRAY)
      { cout << "Konstruktor CA\n";}
    ~CA(){ cout << "Destruktor CA\n";}
    void SetNumber(int a){m_iNumber=a;}
    int GetNumber(void) const {return m_iNumber;}
};

class CB{
  private:
    CA m_CA[SIZEARRAY];
  public:
    CB() { cout << "Konstruktor CB\n";}
    ~CB(){ cout << "Destruktor CB\n";}

    int Suma(void) const{
      int iSuma=0;
      for(int i=0;i<SIZEARRAY;i++)
        iSuma+=m_CA[i].GetNumber();
      
      return iSuma;
};

int main (void)
{
  CB a;
  cout<<"\n "<<a.Suma()<<"\n\n";
  return 0;

}
```

### Vypíše se

```
Konstruktor CA Konstruktor CA Konstruktor CA
Konstruktor CB
9
Destruktor CB
Destruktor CA Destruktor CA Destruktor CA
```

## Spřátelená funkce a spřátelená třída

* Spřátelená funkce není členem třídy, ale má přístup k jejím privátním prvkům.
* **friend** - povoluje přístup metodám a funkcím (spřátelené)
* **publicXfrind** - public zpřístupní datový člen všem funkcím a metodám, frind pouze některým (zvoleným)

### Příklad

```
#include <iostream.h>

class myclass {
  int n, d;
public:
  myclass(int i, int j) { n = i; d = j; }
  friend int isfactor(myclass ob); //spratelena funkce
};

int isfactor(myclass ob)
{
  if(!(ob.n % ob.d)) return 1;
  else return 0;
}

int main()
{
  myclass ob1(10, 2), ob2(13, 3);

  if(isfactor(ob1)) cout << "10 je delitelne 2\n";
  else cout << "10 neni delitelne 2\n";

  if(isfactor(ob2)) cout << "13 je delitelne 3\n";
  else cout << "13 neni delitelne 3\n";

  return 0;
}
```

* Musíme si uvědomit, že spřátelená funkce není členem třídy jejímž je přítelem. Není tedy možné volat spřátelenou funkci s využitím jména objektu a tečkového či šipkového operátoru. Přestože tedy spřátelená funkce zná privátní prvky třídy, s níž je spřátelená, může k nim přistupovat pouze přes objekty třídy.
* Spřátelená funkce není dědičná. Proto, když základní třída obsahuje spřátelenou funkci, pak tato třída není spřátelena s odvozenou funkcí. Dále platí že spřátelená funkce může být spřátelena s více třídami.

## Dědičnost

### Jednoduchá dědičnost

* Základní vztah mezi třídami
* Objekt dědí vlastnosti z jiného objektu a přidává si svoje vlastní
* Vytváření nových tříd (odvozená), které se odvozují od tříd jiných (bázová, rodičovská)
* Jednoduchá dědičnost = třída dědí pouze z jedné třídy
