# 20.Pokročilé techniky objektového programování

## Agregace

* Mluvíme o agregaci pokud nějaká **třída obsahuje jiné třídy (také se jím říká komponenty)**. 
* Pomocí agregace můžeme tvořit složitější třídy pomocí jednodušších. 
* Konstruktory se v takovém případě chovají tak, že dříve, než se spustí konstruktor třídy, jejíž instanci vytváříme, nejprve se vytvoří instance tříd, které tato třída obsahuje (jejich konstruktory se tedy volají dříve). Volání destruktorů probíhá přesně opačně.

### Příklad

```
#include<iostream>
#define SIZEARRAY 3
using namespace std;

class CA{
  private:
  int m_iNumber;
  
  public:
    CA():m_iNumber(SIZEARRAY)
      { cout << "Konstruktor CA\n";}
    ~CA(){ cout << "Destruktor CA\n";}
    void SetNumber(int a){m_iNumber=a;}
    int GetNumber(void) const {return m_iNumber;}
};

class CB{
  private:
    CA m_CA[SIZEARRAY];
  public:
    CB() { cout << "Konstruktor CB\n";}
    ~CB(){ cout << "Destruktor CB\n";}

    int Suma(void) const{
      int iSuma=0;
      for(int i=0;i<SIZEARRAY;i++)
        iSuma+=m_CA[i].GetNumber();
      
      return iSuma;
};

int main (void)
{
  CB a;
  cout<<"\n "<<a.Suma()<<"\n\n";
  return 0;

}
```

### Vypíše se

```
Konstruktor CA Konstruktor CA Konstruktor CA
Konstruktor CB
9
Destruktor CB
Destruktor CA Destruktor CA Destruktor CA
```

## Spřátelená funkce a spřátelená třída

* Spřátelená funkce není členem třídy, ale má přístup k jejím privátním prvkům.
* **friend** - povoluje přístup metodám a funkcím (spřátelené)
* **publicXfrind** - public zpřístupní datový člen všem funkcím a metodám, frind pouze některým (zvoleným)

### Příklad

```
#include <iostream.h>

class myclass {
  int n, d;
public:
  myclass(int i, int j) { n = i; d = j; }
  friend int isfactor(myclass ob); //spratelena funkce
};

int isfactor(myclass ob)
{
  if(!(ob.n % ob.d)) return 1;
  else return 0;
}

int main()
{
  myclass ob1(10, 2), ob2(13, 3);

  if(isfactor(ob1)) cout << "10 je delitelne 2\n";
  else cout << "10 neni delitelne 2\n";

  if(isfactor(ob2)) cout << "13 je delitelne 3\n";
  else cout << "13 neni delitelne 3\n";

  return 0;
}
```

* Musíme si uvědomit, že spřátelená funkce není členem třídy jejímž je přítelem. Není tedy možné volat spřátelenou funkci s využitím jména objektu a tečkového či šipkového operátoru. Přestože tedy spřátelená funkce zná privátní prvky třídy, s níž je spřátelená, může k nim přistupovat pouze přes objekty třídy.
* Spřátelená funkce není dědičná. Proto, když základní třída obsahuje spřátelenou funkci, pak tato třída není spřátelena s odvozenou funkcí. Dále platí že spřátelená funkce může být spřátelena s více třídami.

## Dědičnost

### Jednoduchá dědičnost

* Základní vztah mezi třídami
* Objekt dědí vlastnosti z jiného objektu a přidává si svoje vlastní
* Vytváření nových tříd (odvozená), které se odvozují od tříd jiných (bázová, rodičovská)
* Jednoduchá dědičnost = třída dědí pouze z jedné třídy

#### Příklad

```
class NakladniVozidlo : public Vozidlo{ //Třída NakladniVozidlo dědí z třídy Vozidlo
…
};
```

### Vícenásobná dědičnost

* nová třída, která dědí z více než jednoho předka
* stejné pravidla jako jednuduchá dědičnost
* vzniká však několik problémů

#### Příklad

```
class potomek : public Predek1, public Predek2 …
{};
```

#### Problémy s vícenásobnou dědičností

1. **Konflikt jmen**
2. **Opakovaná dědičnost**
3. **Konstruktory a destruktory**

## Direktivy public, private, protected

### Public

* přístupné odkludkoliv
* značí veřejné dědění
* nejtypičtěští způsob dědění
* potomek získá věškeré veřejné a chráněné členy rodičovské třídy se stejnými oprávněními, s jakými byly deklarovány v rodičovské třídě

### Private

* proměnná nebo metoda není přístupná nikde jinde než ve třídě, ve které byla definována
* soukromé dědění
* pokud nespecifikujeme přístupový modifikátor, program proměnnou nebo metodu sám definuje na private

### Protected

* k položkám bude mít přístup pouze členové třídy a třídy odvozené (zděděné)
* přístupnost je dána i způsobem dědění

## Způsoby dědění

V jazyce C++ existují tři možnosti, jak dědit. Tyto možnosti se liší v závislosti na tom, zda budou jednotlivé metody a atributy v potomkovi viditelné. Tyto způsoby jsou private, public (nejčastější) a protected.
| | Položka v předkovi je **private**  |Položka v předkovi je **protected**|Položka v předkovi je **public**|
| --- | --- | --- | --- |
| Dědění je private | položka v potomkovi není přístupná | položka v potomkovi je private | položka v potomkovi je private |
| Dědění je protected | položka v potomkovi není přístupná | položka v potomkovi je protected | položka v potomkovi je protected |
| Dědění je public | položka v potomkovi není přístupná | položka v potomkovi je protected | položka v potomkovi je public |
